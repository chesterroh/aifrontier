---
episodeNumber: 75
title: "(수학 공식 없는) 강화 학습 이야기"
description: "중국 Moonshot의 Kimi K2 Thinking 모델이 GPT-5와 Sonnet 4.5를 넘어서는 벤치마크 성적을 기록하며 포스트 트레이닝 시대의 빠른 모델 발전을 보여주고 있습니..."
publishedAt: 2026-01-30
duration: "1:04:40"
youtubeId: "7pGfU6AC4XY"
thumbnail: "https://i.ytimg.com/vi/7pGfU6AC4XY/maxresdefault.jpg"
hosts:
  - 노정석
  - 최승준
chapters:
  - time: "0:00"
    title: "오프닝: Kimi K2 모델 발표와 강화 학습"
  - time: "0:38"
    title: "Kimi K2 모델의 특징과 벤치마크"
  - time: "1:14"
    title: "포스트 트레이닝 시대와 모델 개발 주기"
  - time: "2:55"
    title: "MoE와 양자화를 통한 모델 경량화"
  - time: "5:43"
    title: "포스트 트레이닝 레시피의 중요성"
  - time: "7:26"
    title: "강화 학습(RL)에 대한 새로운 관점"
  - time: "9:30"
    title: "지도 학습 vs 강화 학습: 자율주행 비유"
  - time: "12:43"
    title: "강화 학습의 핵심: Credit Assignment Problem"
  - time: "15:10"
    title: "LLM에 강화 학습이 도입된 이유: RLHF"
  - time: "17:18"
    title: "SFT의 한계와 할루시네이션 문제"
  - time: "20:15"
    title: "On-Policy vs. Off-Policy 학습의 개념"
  - time: "23:31"
    title: "일반화를 위한 모델의 문제 해결 능력"
  - time: "30:28"
    title: "인터넷 데이터의 한계: 중간 과정의 부재"
  - time: "33:38"
    title: "프리트레이닝과 탐색 공간의 축소"
  - time: "36:25"
    title: "LLM의 학습과 Perplexity의 의미"
  - time: "39:17"
    title: "추론의 분기점: Entropy가 높은 토큰"
  - time: "42:04"
    title: "집단적 추론의 학습: 인터넷 포럼 사례"
  - time: "44:14"
    title: "강화 학습을 통한 추론 능력의 발현"
  - time: "49:01"
    title: "강화 학습은 기존 능력을 꺼내는 것일까?"
  - time: "52:26"
    title: "성공적인 강화 학습을 위한 조건"
  - time: "57:27"
    title: "DeepSeek R1의 추론 학습 방식"
  - time: "60:05"
    title: "마무리: On-policy RL과 인생: Jason Wei의 이야기"
lang: "ko"
alternateSlug: null
---

## 오프닝: Kimi K2 모델 발표와 강화 학습    *00:00*

<span class="paragraph-timestamp" data-ts="00:00">00:00</span> **노정석** 녹화를 하고 있는 오늘은 2025년 11월 8일 토요일 아침입니다.

정말 이제 저희가 Gemini 3.0을 기다리고 있는데 곧 나오긴 하려나 봐요.

엊그제, 어제죠, 한국 날짜로 중국의 프런티어 랩 중 하나인 Moonshot에서 Kimi K2 Thinking 모델을 발표했는데요.

각종 벤치마크에서 다른 미국의 프런티어 모델들을 넘어서는 결과들을 보여주고 있어요.

그래서 여전히 reinforcement learning, RL, 강화 학습이 큰 화두인 것 같아서 오늘 성현 님과 함께 RL 부분 더 깊게 한번 파보려고 합니다.

네, 안녕하세요.

## Kimi K2 모델의 특징과 벤치마크    *00:38*

<span class="paragraph-timestamp" data-ts="00:39">00:39</span> **김성현** 안녕하세요. Kimi K2 모델이 나와서 굉장히 화제가 되고 있고 지금도 되고 있는데요. 가장 화제가 됐던 것은 벤치마크 스코어일 것 같습니다.

벤치마크 스코어에서 다른 모델 딱 두 가지랑 비교하고 있거든요. GPT-5하고 Sonnet 4.5 Thinking입니다. 그러니까 지금 최고 상태에 있는 모델들과 비교하고 있고 그 모델들과 비교해서도 뒤지지 않거나 어떤 벤치마크에서는 더 좋은 성능을 기록하고 있는 거죠.

또 한 가지 흥미로운 점은 Kimi K2가 그 이전에는 추론 모델은 아니었고 instruct 모델이긴 했는데 instruct 모델이 나온 게 9월 정도거든요. 그래서 새로운 모델이 나오는 주기가 점점 빨라지고 있습니다.

## 포스트 트레이닝 시대와 모델 개발 주기    *01:14*

<span class="paragraph-timestamp" data-ts="01:19">01:19</span> **김성현** 이제 프리트레이닝이 아니라 포스트 트레이닝 시대로 넘어오면서 이제 각 회사들이 포스트 트레이닝 레시피를 개량하고 있고 그 개량된 레시피들이 모델에 도입돼서 개선된 모델이 나오는 속도는 프리트레이닝을 개선한 다음에 다시 포스트 트레이닝을 하고 새로운 모델이 나오는 속도에 비해서 그 주기가 굉장히 빨라지는 거죠.

아마 GPT-5나 OpenAI나 Anthropic에서 나오는 모델들도 그 주기는 계속 빨라질 것 같습니다. 여러 가지 소개하고 있는데, 한 번의 지시에 대해서 200~300개의 tool use를 수행할 수 있다거나 이런 얘기를 쭉 하고 있고요.

스코어 잘 나온다, 성능 잘 나온다 이런 얘기들이 있고, 그 외에 흥미로운 점은 Kimi K2 같은 경우는 Kimi 이전 모델들도 마찬가지였을 것 같은데 코딩하고 수학 관련된 것만 강조하지는 않습니다.

이 사람들은 늘 보면 creative writing, 창조적인 글쓰기 글쓰기 능력 같은 것도 강조를 많이 해요. 그리고 제가 써보면 확실히 Kimi K2, Moonshot 모델들은 Moonshot 모델들의 어떤 문체나 스타일이 있는 것 같긴 합니다.

글쓰기에서 그런 부분도 흥미로운 점이고 일반적인 능력 같은 것도 계속 강조하면서 가져가고 있다 이런 것들이 흥미로운 부분인 것 같아요. 특히 요즘 '뾰족한 지능'이라고 표현을 많이 하던데, 수학, 코딩만 잘하는 모델 혹은 특정 부분만 잘하는 모델, 이런 부분들에 대한 관심이 다시 높아지는 것 같은데

그와는 별개로 프런티어 기업들은 여전히 범용적인 지능, 그리고 다양한 작업을 수행할 수 있는 모델, 이런 부분들에 대한 관심이 높고 그 부분들을 계속 추구하고 있는 것 같습니다.

## MoE와 양자화를 통한 모델 경량화    *02:55*

<span class="paragraph-timestamp" data-ts="03:00">03:00</span> **김성현** 그리고 약간 더 디테일인데, 추론 효율성이라고 표현하면서 이건 추론 효율성이라는 건 서비스의 효율성입니다. 서비스의 효율성이라는 것을 표현하면서 포스트 트레이닝 과정에서 quantization-aware training을 했다고 말하고 있어요.

Quantization-aware training이라는 건 소위 말하는 quantization, 혹은 양자화를 통해서 모델의 덩치를 줄이는 작업 같은 것을 학습 단계에서 성능 감소를 줄이기 위한 테크닉인데, 여기서 보면 MoE 부분, MoE FFN 부분에 대해서 INT4 quantization을 했다고 합니다.

그 OpenAI에서 나왔던 gpt-oss와 비슷하게 4-bit quantization을 했거든요. MXFP4라는 형태로 4-bit quantization을 했는데 그것과 비슷하게 INT4 quantization을 포스트 트레이닝 단계에서 도입하고 있고 이런 흐름들은 점점 더 대세가 될 것 같습니다.

이게 아마 MoE 연구와 관련해서 좀 더 깊게 들어가 봐야 할 부분이긴 하지만, MoE가, 특히 MoE 부분이 quantization이 더 일반적인 dense 모델에 비해서 더 잘 된다는 얘기가 많이 있습니다.

자연스러운 게, 모델의 웨이트가 모델이 학습을 많이 하면 많이 할수록 quantization이 어려워지거든요. 왜냐하면 모델의 웨이트에 정보가 더 많이 들어가는 거죠. 학습을 많이 할수록 그런데 MoE 같은 경우는 각 모델의 모듈이 모든 데이터에 대해서 학습되는 게 아니고 부분적으로 학습되므로 압축할 수 있는 가능성이 더 높다고 볼 수 있습니다.

그렇기 때문에 gpt-oss 같은 경우도 MoE 부분을 특히 양자화를 했고 이제 Kimi 같은 경우도 그 부분을 양자화를 하고 있는 거죠.

그래서 이런 흐름들이 아마 앞으로 점점 더 자주 보게 될 기본적인 테크닉이 될 것 같습니다.

<span class="paragraph-timestamp" data-ts="04:38">04:38</span> **노정석** 모델 사이즈도 그럼 그 덕분에 많이 줄어들었겠네요. 이게 1조 파라미터 모델일 텐데 사이즈가 그럼 1TB가 안 되겠네요. 이론상 500GB 정도 돼야 하는 건가요? 한 600GB?

<span class="paragraph-timestamp" data-ts="04:53">04:53</span> **김성현** 이게 대부분의 웨이트가 MoE 부분에 들어가 있기 때문에 아마 1TB, 그 정도 수준은 안 될 겁니다. 물론 quantization해서 메모리에 띄웠을 때 1TB 수준이 아니라 500GB 정도, 말씀하신 대로 그 정도로 뜨게 될 겁니다.

<span class="paragraph-timestamp" data-ts="05:16">05:16</span> **노정석** 그 정도면 진짜 8개 GPU 달린 것 한 대에서도 돌아갈 수 있는 수준이겠네요.

<span class="paragraph-timestamp" data-ts="05:20">05:20</span> **김성현** 예, 간신히 밀어 넣을 수 있을 것 같네요.

<span class="paragraph-timestamp" data-ts="05:24">05:24</span> **노정석** 그러니까요. 성능은 유지되는데 계속 작아지고 컴퓨팅 효율성은 높아지고 있다.

<span class="paragraph-timestamp" data-ts="05:34">05:34</span> **최승준** 파라미터는 1조 급인데 용량으로 치면 500GB 정도 된다고 추정하시는 거죠.

<span class="paragraph-timestamp" data-ts="05:38">05:38</span> **김성현** 네, 실질적인 용량은 그 정도로 줄어들 겁니다. 왜냐하면 절반 크기가 되니까요. 아마 이런 흐름을 계속 보게 될 것 같습니다.

## 포스트 트레이닝 레시피의 중요성    *05:43*

<span class="paragraph-timestamp" data-ts="05:48">05:48</span> **김성현** 포스트 트레이닝과 RL에 방점이 찍히면서 RL의 학습 레시피들이 빠르게 개량되고 있고 그 빠르게 개량된 레시피들이 모델에 적용돼서 출시되는 주기가 빨라지고 있거든요. 그런 것들을 계속 보게 될 것 같고, 심지어 그런 레시피 개선 같은 것은 테크 리포트를 따로 내지도 않죠.

얼마나 좋은 레시피를 갖고 있는가가 아마 프런티어 기업들의 경쟁력이 될 겁니다.

프리트레이닝 같은 경우는 지금까지는 있는 데이터를 잘 쓴다에 가깝다면, 포스트 트레이닝은 데이터를 창조한다는 느낌에 더 가깝거든요.

그러면 이제 그 창조를 얼마나 잘하는가, 이 부분이 노하우가 될 것이고, 그 부분에서 프런티어 기업들의 경쟁력이 굉장히 크게 갈리게 될 거라고 봅니다.

아마 포스트 트레이닝의 레시피나 요령 같은 것은 각 기업마다 많이 다를 거라고 생각합니다.

<span class="paragraph-timestamp" data-ts="06:40">06:40</span> **노정석** 네, 많이 달라졌을 것이다. 네, 그리고 철학적으로 중요도에 방점을 찍는 것, 이런 것도 Anthropic이나 이런 데는 코딩이나 현실적인 문제, B2B use에 굉장히 방점이 가 있다면 OpenAI나 Kimi나 말씀하신 것처럼 좀 더 generalization, 이런 쪽에 훨씬 더 방점이 가 있는 느낌도 있습니다.

<span class="paragraph-timestamp" data-ts="06:59">06:59</span> **김성현** 네, Anthropic도 물론 general한 것 계속 챙기긴 하겠지만 그 부분에서 특화하는 방향으로 갈 것인가, 아니면 전반적인 것을 다 가져갈 것인가, 이런 부분이 있겠죠.

그렇지만 저는 기본적으로 프런티어 랩들의 기조는 다 전반적인 것들을 같이 끌고 간다일 것 같습니다.

저는 일반적인 지능과 능력이라는 것이 그렇게 다른 능력과 완전히 분리될 수 있는 것은 아니라고 보거든요.

그런데 이건 약간 철학적인 부분이긴 합니다.

<span class="paragraph-timestamp" data-ts="07:25">07:25</span> **최승준** 쭉쭉 가보시죠.

## 강화 학습(RL)에 대한 새로운 관점    *07:26*

<span class="paragraph-timestamp" data-ts="07:29">07:29</span> **김성현** 네, 그럼 이제 원래 하려고 했던 reinforcement learning으로 넘어가려고 합니다. 저번에 제가 RLVR과 관련해서 다뤘었는데, 다루고 났을 때는 그 정도로도 충분할 거라고 생각했는데 막상 하고 나니 좀 더 깊게 잘 다뤄봤으면 좋겠다는 생각이 많이 들더라고요. 그래서 reinforcement learning에 대한 이야기를 다시 해보려고 합니다.

제 또래 엔지니어들한테 reinforcement learning은 굉장히 각별한 경우가 많습니다. 왜냐하면 AlphaGo와 함께 시작했거든요. 딥러닝을요. 그래서 AlphaGo를 재현하는 것이 첫 번째 프로젝트였던 분들도 굉장히 많을 거고요. 그런데 그에 비해서 저는 강화 학습으로 시작한 편은 아닙니다.

저는 그냥 지도 학습으로 시작했고, 강화 학습에 대해서는 '그렇게 골치 아픈 걸 왜 굳이 하려고 해?' 약간 이런 느낌이었거든요. 최근까지도 그랬다가 LLM 시대가 오면서 강화 학습을 안 할 수가 없게 되었고 결국 강화 학습과 관련된 이야기를 하게 됐습니다. 그런데 그런 의미에서는 강화 학습으로 시작한 분들하고 저하고는 약간 강화 학습에 대한 관점이나 감상이 다를 수도 있을 것 같기는 해요.

이전부터 강화 학습에 대해서 애정을 깊이 가지고 계셨던 분들하고 저는 약간 강화 학습하면 너무 골치 아픈 대상, 이런 느낌으로 보다가 필요에 의해서 다시 강화 학습에 관심을 갖게 된 입장에서는 관점이 좀 다를 것 같긴 합니다. 그렇지만 새로운 관점도 아마 흥미로울 수도 있을 것 같다고 생각합니다.

그래서 강화 학습이 무엇인가에 대해서 다시 간략하게 소개를 하자면 어떤 에이전트가 있고 환경 속에서 에이전트가 행동을 합니다. 그러면 행동을 하면 환경이 에이전트의 행동에 의해 어떤 변화를 하겠죠. 상태가 변화한다고 표현하고요. 그리고 경우에 따라서는 거기서 보상이라고 하는, 이 환경에 정의된 보상이 들어오기도 할 겁니다.

그래서 게임에서 높은 고득점을 얻었다거나 하는 것들이 하나의 보상이 될 수 있겠죠. 그랬을 때 이 환경 속에서 행동하는 에이전트가 이 보상을 최대화할 수 있도록 학습하는 방법이 강화 학습입니다. 그리고 이 부분이 지도 학습하고는 좀 다른 방법이기도 해요.

## 지도 학습 vs 강화 학습: 자율주행 비유    *09:30*

<span class="paragraph-timestamp" data-ts="09:36">09:36</span> **김성현** 그런데 지도 학습은 물론 강화 학습과 완전히 다른 거라고 보기는 어려운 점도 있습니다. 왜냐하면 지도 학습의 기법이 강화 학습의 일부로 생각할 수 있는 부분도 있거든요. 그런데 강화 학습이라고 말할 때 지도 학습과 좀 다른 점은 에이전트가 어떻게 행동해야 된다는 것들을 어떤 인간 전문가 같은 사람들이 가르쳐 주지는 않는다는 거죠.

<span class="paragraph-timestamp" data-ts="10:02">10:02</span> **최승준** 약간 헷갈리는 부분이 비지도 학습의 맥락 아닌가요? 지도 학습 때 RL이 아니라 비지도 학습 때 RL인 거 아니에요?

<span class="paragraph-timestamp" data-ts="10:04">10:04</span> **노정석** 지도 학습이라고 해도 맞죠. 성현님이 의미하셨던 거는 강화 학습이 진행되면서 성공한 것들에 대해 보상을 얻고 업데이트하는 이런 부분은 사실 지도 학습에서 레이블에 맞춰서 학습하는 과정과도 비슷하다는 거죠.

<span class="paragraph-timestamp" data-ts="10:21">10:21</span> **김성현** 이건 자율주행을 비유로 들면 좋을 것 같아요. 자율주행을 비유로 들면 지도 학습으로 자율주행을 학습한다고 하면 사람이 어떤 주행하는 궤적을 만들겠죠. 이렇게 운전하는 과정 같은 것들에 대한 기록을 만들 거고 그 기록을 모델이 모사하도록 학습하는 것이 지도 학습적인 관점에 가깝습니다.

강화 학습을 사용한다고 하면 그보다는 어떤 목표를 주고 성공적으로 목표, 즉 목적지에 도달하는 것을 보상으로 주고 어떻게 운전할지는 에이전트, 즉 인공지능 모델이 직접 찾도록 만드는 쪽에 가깝죠. 그게 지도 학습과 강화 학습을 대비했을 때 가장 크게 차이가 나는 부분이기도 합니다.

그러니까 어떻게 문제를 풀어야 하는지는 가르쳐주지 않는 거죠. 문제를 풀어라라는 목적만 주는 것에 가깝습니다. 그런데 그렇기 때문에 더 장점이 생기는데요.

어떤 인간이 만든 데이터를 가지고 인간이 만든 데이터를 모사하도록 학습하면 결국 인간 수준의 성능이 나오겠죠. 물론 완전히 그렇다고만 말할 수는 없지만 대체로 인간 수준의 성능에 도달하는 것이 목표가 될 겁니다. 왜냐하면 인간의 방법을 따라 하는 거니까요.

사실 인간보다 못할 가능성이 높죠. 모방이라는 것은. 그런데 강화 학습은 그 방법을 직접 모델이 찾도록 만드는 것이기 때문에 인간의 수준을 뛰어넘을 가능성이 생깁니다.

그러니까 바둑에서 그것을 가장 잘 보여주고 있죠. 모델이 스스로 바둑을 두는 방법을 찾으니까 인간을 뛰어넘는 수준의 바둑을 둘 수 있게 되는 거죠. 그런 의미에서 머신러닝 관련 방법 중에서 초인적인, 즉 인간을 뛰어넘는 성능에 도달할 수 있는 유일한 방법이라고도 볼 수 있습니다. 강화 학습이요.

강화 학습의 기법이 뭐냐, 어떤 식으로 일어나는 거냐고 얘기를 하면 이걸 수학적으로 접근하면 굉장히 복잡한데 Karpathy가 아주 간단하게 요약을 했더라고요. 강화 학습에 대해서 잔인한 방식으로 표현을 하긴 했는데 그렇다고 아주 틀린 표현도 아닙니다.

기본적인 요령은 에이전트가 행동을 수행합니다. 환경 속에서 행동을 수행하게 한 다음에 어쩌다 행동을 하다 보면 보상이 들어오겠죠. 그러면 보상이 들어올 때까지 했던 행동들의 확률을 높이는 겁니다. 이게 가장 기본적인 아이디어라고 보시면 될 것 같아요.

행동을 하게 한 다음에 보상이 들어오면 그 보상이 들어왔을 때 보상이 들어올 때까지 했던 행동들의 확률을 다 높이는 거죠. 그러면 약간 이상한 생각이 들긴 합니다.

## 강화 학습의 핵심: Credit Assignment Problem    *12:43*

<span class="paragraph-timestamp" data-ts="12:46">12:46</span> **김성현** 그 행동들 중에서 어떤 행동들은 도움이 안 됐을 거고 어떤 행동들은 도움이 됐을 거잖아요. 특히 무작위로 행동을 하다 보면 그런 일이 더 일어나겠죠. 그러면 그중에서 실제로 도움이 되는 행동들만 확률을 높이는 게 좋겠죠.

그런데 이게 Credit Assignment Problem이라고 부르는 문제인데, 한국어로 어떻게 번역하면 좋을지 바로 생각은 나지 않네요. 그러니까 어떤 행동이 실제로 도움이 되는 행동인가를 찾아내는 문제인데, 이게 잘 생각해 보시면 쉽지 않은 문제입니다.

사람도 어떤 선험적인 지식이 전혀 없는 상태에서 어떤 좋은 결과가 일어났을 때 그 결과로 이어진 행동이 무엇일까, 그것을 어떻게 알아낼 수 있을까 생각해 보면 쉽지 않은 문제입니다. 사람들도 다 이전 경험이나 추론을 통해서 알아내는 거지, 그냥 던져졌을 때 어떤 행동이 도움이 됐을까를 알아내긴 참 어렵죠.

그리고 사람들도 이런 부분에 대해서 실수를 굉장히 많이 합니다. 그러니까 패턴이 없는 곳에서 패턴을 찾아내려고 한다거나, 전혀 관계가 없는데 그 행동이 도움이 될 거라고 생각한다거나 이런 일들이 많이 일어나잖아요. 이게 전반적으로 어려운 문제라는 걸 시사하는 겁니다.

그러니까 도박 같은 데서 사람들이 그런 실수를 굉장히 많이 하죠. 패턴이 있을 거라고 생각하고, 어떤 행동이 도움이 됐을 거라고 생각해서 징크스 같은 게 발생하고 이런 거죠.

그래서 이 문제가 상당히 어려운 문제고 알파고 덕분에 강화 학습이 영광스러운 모습들을 많이 보긴 했지만 여전히 이런 부분에 대해서 특히 보상이 아주 띄엄띄엄 주어지는 경우, 행동을 한 수백 번, 수천 번 한 이후에만 보상이 주어지는 경우에는 여전히 이 문제는 어려운 문제입니다.

강화 학습은 어려운 문제고, 그 강화 학습으로 Atari 게임들을 풀고 있을 때 Atari 게임들이 많이 풀렸어요. 그런데 그중에 Montezuma's Revenge라고 하는 게임이 하나 있었거든요. 지금 여기 스크린샷에 띄워놓은 게임인데, 이 게임은 제가 알기로 여전히 지금까지도 인간 평균 수준까지는 도달했는데 변칙적인 방법을 쓰지 않고는, 예를 들어 사람의 가이드라거나 환경을 리셋할 수 있는 능력이라거나 이런 걸 주지 않고는 여전히 초인적인 능력에 도달하지 못했다고 알고 있습니다.

그러니까 강화 학습에 잘 맞지 않는, 즉 많은 행동을 한 이후에만 보상이 들어오는 환경에 대해서는 여전히 어려운 상태인 거죠. 그래서 전반적으로 쉽지 않은 문제입니다.

## LLM에 강화 학습이 도입된 이유: RLHF    *15:10*

<span class="paragraph-timestamp" data-ts="15:10">15:10</span> **김성현** 그러면 이 강화 학습이 LLM에 대해서 왜 도입이 됐는지, 그리고 어떤 형태로 도입이 됐는지를 소개하는 걸로 시작을 하려고 합니다. RLHF라는 것으로 가장 최초로 도입이 됐다고 볼 수 있을 것 같은데요. 물론 그 이전에도 좀 다른 형태로 도입된 사례들이 있긴 하지만 가장 주류에서 도입된 사례는 RLHF입니다.

RLHF가 RL이 맞냐 아니냐 하는 논쟁은 많고, 강화 학습하는 사람들은 RL이 아니라고 하긴 하지만 어쨌든 저는 RL이라고 생각합니다. 기본적인 아이디어는 그렇습니다. 이렇습니다.

LLM한테 어떤 프롬프트를 주고 응답을 두 개 생성하게 합니다. 그러면 응답을 2개 생성하면 그 응답 중에 좋은 응답이 있고 나쁜 응답이 있겠죠. 그러면 사람이 어떤 응답이 좋았고, 어떤 응답은 그에 비해 별로였는지를 레이블링합니다.

레이블링을 한 다음에 이 레이블 결과를 가지고 보상 모델을 만듭니다. 이 보상 모델은 응답들을 받아서 그 응답이 좋은 응답인지 아닌지를 사람의 평가와 비슷하게 예측하도록 만든 모델인 거죠. 그리고 이 보상 모델이 RL, 즉 강화 학습에서 보상을 제공하는 보상 함수의 역할을 하게 됩니다.

이렇게 보상 모델을 만든 다음 LLM을 가지고 다시 응답을 여러 개 생성하게 합니다. 여러 개 생성하게 한 다음 보상 모델에 넣으면 이 응답이 좋았는지 안 좋았는지를 평가하게 되겠죠. 보상 모델이 그러면 그 평가 점수를 최대화하도록, 즉 보상을 최대화하도록 RL을 하는 겁니다.

그러면 보상이 최대가 되는, 그러니까 사람이 긍정적으로 평가하는 응답이 나오게끔 모델이 학습되겠죠. 그래서 이 과정이 사람과의 정렬이 됩니다. 사람이 선호하는 응답을 모델이 생성하도록 모델을 학습시켜 나가고 그렇기 때문에 사람과 정렬하게 되는 거죠. 사람의 선호와 이런 형태로 학습하게 됩니다. 이게 RLHF의 기본적인 아이디어입니다.

생각해 보면 '이걸 왜 하지?'라는 생각이 들 수 있을 거라고 생각해요. 그리고 실제로 '이걸 왜 하지?'라는 생각을 해서 안 하는 경우도 많이 있었습니다. 특히 오픈 소스 모델들의 경우에는 '이걸 굳이 이렇게 해야 돼?'라는 경우가 많았고 '왜 하지?'라는 의견들이 많아서 안 하는 경우가 많았는데 이 문제에 대해서 여러 가지 이유가 있을 수 있겠지만 가장 대표적으로 들 수 있는 건 할루시네이션 문제일 것 같아요.

## SFT의 한계와 할루시네이션 문제    *17:18*

<span class="paragraph-timestamp" data-ts="17:28">17:28</span> **김성현** 일단 '왜 하지?'라고 하면 그러면 RLHF 말고 다른 방법이 있는가라고 생각할 수 있을 텐데 그 부분에 대해서 가장 대표적인 방법이 소위 SFT라고 부르는 방법입니다. 이건 전문가 혹은 사람이 정답을 작성하는 거죠.

심지어는 사람이 작성하는 게 아니라 GPT-4나 이런 이미 정렬된 모델들이 생성한 응답을 가져와서 정답을 만들기도 합니다. 어쨌든 전문가가 정답을 작성합니다. 리히텐슈타인의 수도는 저도 이걸 찾아보고 아는데 파두치라고 하더라고요. 이런 데이터를 작성하는 거죠.

그리고 모델은 이 전문가가 작성한 정답을 모사하도록 학습합니다. Next Token Prediction을 그대로 사용해요. '리히텐슈타인의 수도는'이라는 입력에 대해서 '파두치'라는 토큰을 예측하게 학습시키는 겁니다. 이게 SFT의 기본적인 아이디어고 많은 경우에 'RLHF를 굳이 할 필요가 있어?' 그냥 이렇게 하면 '되는 거 아니야?'라는 식으로 접근을 많이 했고 실제로 많은 오픈 소스 모델들은 이렇게 학습되었고 지금도 이렇게 학습되고 있습니다.

그런데 여기서 중요하게 봐야 되는 건 학습하는 모델인 LLM하고 전문가는 다른 에이전트예요. LLM은 LLM이라는 에이전트고 전문가는 어쨌든 사람이므로 다른 에이전트입니다. 이 둘은 동일한 존재가 아니에요. 이 부분에 대해서 하나 짚고 넘어가 주의 깊게 생각해야 합니다.

그래서 어떤 일이 발생할 수 있는지를 보면 모델이 아는 질문으로 학습한다고 생각해 볼게요. '프랑스의 수도는 파리다' 이 질문을 가지고 질문과 정답을 가지고 학습한다고 하면 모델이 일단 프랑스의 수도가 파리라는 것을 당연하게도 알고 있다고 가정해 보겠습니다.

그러면 모델이 학습하는 건 뭘까 생각해 보면 질문에 대해서 자기는 일단 파리라는 건 알고 있잖아요. 그러면 자기가 알고 있는 사실을 가지고 '응답을 하면 되겠다' 이 행동 양식을 학습하는 거죠.

그런데 모델이 모르는 질문이라고 가정해 보겠습니다. 리히텐슈타인의 수도 같은 경우는 LLM들이 다 알고 있겠지만, 만약 모른다고 가정하고 '리히텐슈타인의 수도는 파두치'라는 걸 가지고 학습하면 모델이 리히텐슈타인의 수도는 어디인지 모릅니다. 그럼 모델이 뭘 배울까요?

당연히 리히텐슈타인의 수도가 무엇인지도 학습하긴 할 겁니다. 그런데 동시에 배울 수 있는 게, 자기가 모를 때도 '일단 응답을 하자'는 이 행동 양식도 같이 배우게 됩니다.

그래서 OpenAI가 이번에 할루시네이션 논문을 내면서 비슷하게 지적했던 게, 모델이 일단 대답하는 것에 대해서 보상을 받아서 그렇다고 표현하잖아요. 마찬가지입니다. 일단 대답하는 행동 양식을 배우게 되는 거죠.

그리고 이렇게 되니까 모델을 크게 바꿉니다. 새로운 지식도 습득해야 되고, 몰라도 일단 응답하는 것도 습득해야 하고, 모델을 크게 바꾸게 되고 모델을 크게 바꾸는 것들이 보통 안 좋은 결과로 이어집니다. 할루시네이션이 발생하는 거죠.

## On-Policy vs. Off-Policy 학습의 개념    *20:15*

<span class="paragraph-timestamp" data-ts="20:15">20:15</span> **김성현** 이런 경우에는 '일단 몰라도 응답은 하자' '뭐라도' 이런 패턴을 학습하게 되는 거죠. 이 부분에 대해서 왜 이런 문제가 생겨나는지 한번 좀 더 깊게 생각해 볼게요.

On-Policy와 Off-Policy라는 개념이 있습니다. RL의 굉장히 중요한 개념입니다. Off-Policy라고 하는 것은 학습하는 에이전트와 행동하는 에이전트가 따로 있는 겁니다. 행동하는 에이전트가 행동해서 데이터를 만들고 이 데이터를 가지고 학습 에이전트는 학습하는 거죠. 이게 Off-Policy입니다.

보통 Off-Policy가 훨씬 어려운 문제입니다. 예를 들어 가장 극단적인 예를 들면 이게 Sutton 책에서 예제를 가져왔는데 행동하는 에이전트는 요리를 하고 있으면 학습 에이전트는 운전을 배울 수 없죠. 그 데이터를 가지고 원하는 걸 배울 수 없죠.

그러니까 이게 일치되어 있는가와 일치되지 않는가가 학습의 난이도에 굉장히 큰 영향을 줍니다. '그럼 대체 그걸 왜 하냐'라고 생각할 수 있을 것 같아요. '그냥 On-Policy로 하면 되는 거 아니야?'라고 생각할 수 있을 것 같은데 Off-Policy로만 가능한 학습 패턴들이 있습니다.

전문가가 경험하고 그 전문가가 데이터를 생성해서 학생이 그걸 배우는 거죠. 예를 들어 어떤 선생님이 실제로 자기가 경험하고 경험 과정에서 어떤 경험을 축적해서 그 과정을, 그 데이터를 요약해서 학생한테 주는 거죠. 이렇게 하면 좀 더 효율적이잖아요. 자기와는 다른 에이전트가 학습한 결과들도 행동에서 얻은 경험들도 가지고 학습할 수 있으니까 데이터 효율적입니다.

그리고 On-Policy는 제약이 상당히 극단적이거든요. 과거의 자신과 현재의 자신도 서로 다른 에이전트인 겁니다. 학습 과정에서 에이전트가 계속 변화할 텐데 과거에 자신이 했던 경험을 현재의 자신이 쓰기는 어려운 거죠.

그렇기 때문에 데이터의 효율성에서 차이가 크게 나게 됩니다. 그렇기 때문에 Off-Policy를 하고 싶어 하는데 Off-Policy는 상당히 어려운 문제고 그 어려운 문제가 어떤 형태로 일어나는지를 다시 좀 더 보면, 이 고질적인 문제가 있습니다.

전문가가 Off-Policy라고 하는 게 대표적인 형태가 전문가가 행동한 다음에 전문가의 행동 과정을 가지고 모델이 학습하는 거라고 볼 수 있을 것 같고, 이전에 자율 주행의 사례로 들면 인간이 운전한 다음에 인간의 운전을 모델이 배우는 사례가 기본적인 Off-Policy의 사례라고 볼 수 있을 것 같아요.

그런데 인간이 주행한 과정을 가지고 배웠는데 인간은 어떤 경로로 갈 수 있는 능력이 있는데 모델은 그 능력이 없다고 가정해 보겠습니다. A라는 지점에서 인간은 B라는 지점으로 갈 수 있는데 모델은 B라는 지점으로 갈 수 있는 능력이 아직 없는 겁니다.

그러면 모델은 A에서 B로 간 다음에 도착지에 도착하는 이것만 가지고 학습한 거죠. 그런데 모델은 정작 현실에 나가면 B라는 지점으로 갈 수 있는 능력이 없습니다. C라는 지점으로 가버려요.

그래서 C라는 지점으로 가고 나면 이제는 자기가 처음 보는 상황이 발생하는 거죠. 자기가 학습 과정에서 못 봤던 상황이 발생하는 겁니다. 그러면 이제 여기서는 문제를 풀 수 없게 되는 거죠.

이 문제가 어떤 모델이 그 문제를 풀 수 있는가 없는가 하는 문제와 결합됩니다. 모델이 어떤 과제가 주어졌을 때 모델이 그 문제를 풀 수 있는 능력이 있는가 없는가.

그런데 모델이 능력이 없는 상태에서 그 능력이 있다는 걸 전제하고 문제를 풀게 시키면 현실에 나가면 안 되는 거죠. 그리고 이게 머신러닝에서 어떤 개념과도 결부시킬 수 있냐면, 오버피팅 문제와도 유사한 점이 있습니다.

## 일반화를 위한 모델의 문제 해결 능력    *23:31*

<span class="paragraph-timestamp" data-ts="23:41">23:41</span> **김성현** 오버피팅이라는 게 흔히 보면 어떤 데이터가 있을 때 그 데이터를 너무 과적합해서 발생하는 문제라고 표현을 많이 하잖아요. 이 점들이 있을 때 이 점들을 다 이으려고 하니까 굉장히 복잡한 곡선이 만들어지는 거죠. 그런데 사실은 훨씬 단순한 직선이 일반화가 더 잘될 수 있겠죠.

오버피팅에 대한 기본적인 직관은 보통 교과서적인 수준에서의 직관은 데이터의 변수가 적고 모델이 단순하면 오버피팅 가능성이 낮다. 이렇게 표현을 많이 합니다. 그런데 이걸 좀 더 깊게 생각하다 보면 이렇게도 볼 수 있을 것 같아요.

오버피팅이 발생하면 이 데이터의 각 지점들을 전부 외우게 되는 거죠. 암기했다고 표현할 수 있을 겁니다. 이 암기라는 지점이 좀 재미있는 부분인데 우리가 '모델이 어떤 데이터를 암기해서 그대로 풀었다' 이런 표현을 많이 하잖아요.

이 암기와 일반화를 대비해서 생각해 보면 오버피팅 상태는 암기라고 생각할 수 있고, 너무 과한 일반화이긴 하지만 데이터를 암기한 상태인 거고 일반화가 가능한 상태는 암기를 뛰어넘어서 어떤 근본적인 패턴을 예측한 상태인 거죠.

그런데 이 부분에 대해서 한 가지 흥미로운 점이 단순히 데이터의 변수 숫자가 작고 모델이 단순하다는 것을 뛰어넘어서 모델이 풀 수 있는 문제를 주는가가 굉장히 큰 영향을 미칩니다.

여기 작은 사진이 하나 있는데 이미지 분류 문제를 푼다고 가정해 볼게요. 굉장히 작은 사진은 말하자면 변수가 적은 거라고 표현할 수 있겠죠. 픽셀이 작으니까요.

그러면 픽셀이 작은 사진을 주면 더 좋은가 오버피팅이 방지되는가 그렇지도 않은, 그렇게만 볼 수는 없습니다. 여기 작은 사진이 있는데 이 사진이 뭘까요? 이 사진은 사과 사진이거든요.

사과 사진을 리사이징해서 굉장히 작게 줄여놨는데 너무 작은 사진을 주면 변수가 적어진 건 좋은데 이 사진을 가지고 실제 이미지 분류 문제를 푸는 게 불가능하죠. 정보가 없으니까요. 풀 수 있는 문제를 주는 것들이 하나의 중요한 지점입니다.

이게 데이터의 측면에서도 생각할 수 있지만 모델의 측면에서 생각해 볼게요. 모델이 커지면 커질수록 무조건 오버피팅이 발생하는가 또 그렇지도 않습니다.

그렇게만 볼 수도 없는 지점이 있는데 어떤 뉴럴 네트워크 모델에서 레이어가 하나 있을 때마다 덧셈을 한 번 할 수 있다고 생각해 볼게요. 어텐션 같은 거라고 생각해 볼 수도 있겠습니다.

그랬을 때 레이어가 하나 증가할 때마다 풀 수 있는 덧셈의 숫자가, 한 번에 풀 수 있는 덧셈 숫자가 하나씩 늘어나는 거죠. 레이어가 2개 있다고 가정하면 두 번의 덧셈을 풀 수 있을 겁니다.

그래서 덧셈 한 번 하는 문제는 풀 수 있겠죠. 두 번 하는 문제도 풀 수 있을 겁니다. 세 번 하는 문제부터는 이제 모델이 못 풉니다. 모델이 못 푸는 문제에 대해서 모델이 어떻게 행동할까요?

뉴럴 네트워크 모델이 아주 약하면 학습이 아예 안 될 겁니다. 그런데 보통 뉴럴 네트워크 모델이 굉장히 강하거든요. 굉장히 강하기 때문에 데이터를 전부 외워버릴 수 있는 능력이 있는 경우가 많이 있습니다.

그러면 이 문제에 대해서는 문제를 외워버릴 가능성이 높죠. 어떻게 외울 거냐, 여러 가지 가능성이 있겠지만 숫자 4가 나오면 10을 찍는다, 이런 것들을 외울 수 있겠죠. 데이터를 그대로 외워버리는 겁니다.

풀 수 없는 문제에 대해서 데이터를 암기해 버리는 일종의 오버피팅이 나올 수 있겠죠. 오버피팅하는 형태로 모델이 학습되는 거죠. 그래서 이 경우에는 레이어가 3개 있어야 될 겁니다.

레이어가 3개 있다는 건 모델이 커진 거지만 모델이 커졌을 때 오히려 오버피팅이 감소하는 거죠. 그래서 최고의 일반화를 생각하면 최고의 일반화라고 할 수 있는 것들은 많은 경우에 알고리즘을 학습하는 겁니다.

여기 숫자들을 주고 정답들을 줬어요. 숫자와 정답이 있을 때 이 많은 패턴을 다 암기해서 학습할 수도 있습니다. 그런데 최선의 일반화가 가능한 방법은 모델이 정렬 알고리즘을 학습하는 거죠.

그렇다면 모델이 이 상황에서 일반화가 가능하려면 모델에게 정렬 알고리즘을 학습할 수 있는 능력이 있어야 합니다. 정렬 알고리즘을 학습할 수 있는 능력이 없다면 이 패턴들을 다 외워버릴 거고 그러면 일반화가 불가능해지겠죠.

그러니까 정렬 알고리즘을 학습할 수 있을 정도의 규모가 되어야만 모델에게 일반화가 발생할 수 있다는 겁니다. 이것들을 좀 더 확장해서 생각해 볼게요.

하나의 레이어가 수행할 수 있는 연산은 한정적입니다. 보통 어텐션 같은 트랜스포머의 한 레이어가 수행할 수 있는 연산은 한정적이고 레이어의 수는 유한하죠. 그렇기 때문에 하나의 토큰에 대해서 수행할 수 있는 연산의 양은 한정적입니다.

그런데 어떤 토큰을 예측할 때 그 토큰의 예측에 필요한 연산의 양이 이것보다 훨씬 많다면 이는 모델이 풀 수 없는 문제가 되는 거죠.

이것은 간단한 2차 방정식 문제를 가져왔는데 모델이 이 2차 방정식을 한 번에 풀어서 풀어낼 수 있을 만큼의 규모가 안 된다고 생각해 볼게요. 그러면 이 문제는 모델이 풀 수 없을 겁니다.

그럼 이 문제가 주어지면 모델이 할 수 있는 건 그냥 외우는 거죠. 이 방정식이 나오면 이 결과를 내라. 그러면 세상에 존재하는 모든 종류의 2차 방정식을 다 학습하지 않는 이상 일반화는 안 되겠죠.

그런데 이 문제를 푸는 데 필요한 연산의 양을 여러 토큰으로 분산한다면 어떻게 될까요? 그러니까 이 2차 방정식 문제를 단계별로 풀어서 한 단계씩 접근하는 거죠.

그러면 이 2차 방정식 문제에서 정답으로 한 번에 가는 연산에 비해서 이 각 단계의 연산은 좀 더 적을 겁니다. 일단 근의 공식을 가져와서 근의 공식에 숫자를 채워 넣고 채워 넣은 각 숫자에 대해 계산을 하고 계산을 한 다음에 정리해서 정답을 낸다.

이것들은 각 토큰에 대해서 필요한 연산의 양이, 각 단계에 대해서 필요한 연산의 양이 한 번에 푸는 것보다는 적겠죠. 그럼 모델이 풀 수 있는 문제가 되는 겁니다.

모델이 풀 수 있는 문제가 되기 때문에 여기서부터 일반화가 가능해지는 거죠. 모델이 풀 수 없는 문제에 대해서는 암기하게 되고 암기하게 되기 때문에 일반화가 불가능하다고 하면 모델이 풀 수 있는 문제의 형태로 단계를 쪼개주면 그 단계들을 통해서 알고리즘을 학습할 수 있고 알고리즘을 학습할 수 있다면 일반화가 발생하고 일반화가 가능해지죠.

<span class="paragraph-timestamp" data-ts="29:55">29:55</span> **노정석** 이게 어떤 논리로 흐르려고 하는지 이해가 되고 있습니다. 맞는 것 같아요. 계속하시죠. 재밌네요.

<span class="paragraph-timestamp" data-ts="30:04">30:04</span> **김성현** 그러니까 일반화에 대해서는 모델이 풀 수 있는 문제를 풀게 하는 것, 이것이 굉장히 중요한 부분입니다. 단순히 작은, 단순한 모델을 쓰고 변수를 적게 쓰는 것을 뛰어넘어서 필요한 경우에는 모델을 키워야 하고, 필요한 경우에는 시퀀스의 길이를 늘려야 하는 그런 것들이 발생하는 거죠.

## 인터넷 데이터의 한계: 중간 과정의 부재    *30:28*

<span class="paragraph-timestamp" data-ts="30:28">30:28</span> **김성현** 모델이 풀 수 있는 문제를 주기 위해서 그랬을 때 일반화가 가능합니다. 그런데 문제는 인터넷에 이런 데이터가 거의 없습니다.

이것은 Math Stack Exchange에서 나왔던 Cleo라고 하는 굉장히 유명한 유저의 한 사례인데 어떤 유저가 이런 적분 문제를 올렸어요.

몇 시간 정도 지난 후였나, Cleo라는 유저가 한 번에 답을 이렇게 내준 거죠. 그런데 그 답에 대해서 어떠한 과정도, 이게 어떻게 유도됐는지 설명이 하나도 없었습니다.

사람들이 많이 의심했어요. 그래서 자기가 문제를 낸 것도 자기 자신이고 문제를 풀어서 올린 것도 자기 자신이다, 동일인이었다, 아니면 동일인인데 문제를 거꾸로 만들었다, 그러니까 적분에서 시작해서 이 미분 문제를 만든 거다 등등 추정이 많았어요.

의심을 많이 했는데 실제로 그런 건 아니었다고 합니다. 실제로 적분 문제를 풀었다고 했던 것 같아요.

그런데 여하간 실제로 그 사람이 적분 문제를 풀 수 있는 능력이 있었는지 없었는지와는 별개로 인터넷에 이런 데이터가 넘치는 거죠. 이 적분 문제를 한 번에 아무런 중간 과정 없이 풀 수 있는 사람은 세상에 거의 없기 때문에 굉장히 드물겠죠.

그런데 인터넷 데이터에서는 사람들이 이렇게 풀고, 문제를 풀고 있는 것처럼 보입니다. 인터넷에 나와 있는 데이터에서는 사람들이 그냥 이 정도 적분 문제는 한 번에 아무런 중간 과정 없이 푸는 것처럼 되어 있는 거죠.

그런데 인터넷 데이터를 통해서 모델이 배워야 하는데 모델이 배울 수 있는 건 다 이런 식인 거죠.

<span class="paragraph-timestamp" data-ts="31:50">31:50</span> **노정석** 모델이 프리트레이닝에서 배우는 데이터들이 다 저런 식으로 그냥 질문과 정답 형태로 되어 있지, 가운데 어떤 연산이 들어가는지, 그 뭔가 trajectory라고 하는 것, 그게 데이터에 거의 없다는 말씀을 하시는 거죠.

<span class="paragraph-timestamp" data-ts="32:04">32:04</span> **김성현** 극히 드뭅니다. 극히 드물기 때문에 이게 LLM에서 고질적으로 발생하는 문제입니다. 그래서 질문에 대해서 좀 생각하고 답을 하면 좋은데 일단 답부터 하는 거죠. 그런 패턴이 발생합니다.

그래서 실제로 이런 간단한 예제를 가져오면 뉴턴은 짝수 해에 태어났는가, 홀수 해에 태어났는가? 이런 질문을 주면 일단 답을 바로 즉시 내고자 하는 충동을 못 이기는 겁니다.

LLM이 그래서 아무런 과정 없이 그냥 '짝수'라고 대답을 하는 거죠. 그런데 재미있는 게, 바로 응답하는 확률이 제일 높습니다, 대체로.

그런데 확률이 낮긴 하지만 생각하고 답변하는 확률, 그 가능성도 있긴 있어요. 그러니까 뉴턴이 태어난 것은 1643년이었고, 1643년이니까 홀수 해겠네, 이렇게 생각한 다음에 답변하는 패턴이 아예 없지는 않아요. 존재하긴 합니다.

그리고 이 부분이 굉장히 중요한 단초가 됩니다. 대부분의 경우에는 응답을 바로 하려고 하는 충동을 이기지 못하지만 생각하려고 하는 능력, 즉 패턴도 모델에 있긴 있더라 이렇게 되는 거죠.

그래서 추론을 통해서 응답할 수 있는 능력이 LLM에 존재하긴 한다. 그러나 파묻혀 있는 거죠. 굉장히 낮은 확률로요.

<span class="paragraph-timestamp" data-ts="33:16">33:16</span> **노정석** 똑같은 질문이 들어와도 답을 하는 그 다음의 가능성들은 굉장히 여러 갈래의 길이 있는데, 그중에는 충동적으로 답하는 것, 아니면 조금 더 풀어서 설명하면서 정답에 이르는 것, 여러 가지 과정이 있는데 그 과정들을 어떻게 하면 더 생각을 많이 하게 하는가, 이런 쪽이 RL에 사용되게 된다는 이런 논리로 가고 있는 거라고 이해하면 될까요?

## 프리트레이닝과 탐색 공간의 축소    *33:38*

<span class="paragraph-timestamp" data-ts="33:41">33:41</span> **김성현** 결국 이런 LLM이 이 능력을 얻게 되는 건 프리트레이닝이니까, 사실 프리트레이닝과 결부해서 어떤 식으로 이 능력들을 얻게 되는지를 먼저 시작을 하겠습니다.

일단 프리트레이닝은 RL에서 굉장히 중요한 역할을 하나 해줘요. 그래서 만약에 토큰 100개에 해당하는 텍스트를 생성하는 문제라고 생각을 해보겠습니다. 100개 정도를 생성해야 문제 풀 수 있는 문제라고 생각을 해볼게요.

그러면 가능성의 수는 그 LLM의 토큰의 vocabulary 수, 가지고 있는 토큰의 단어의 수의 100제곱이 될 겁니다. Kimi K2를 가져와 보면 Kimi K2 vocabulary가 163,840개 정도더라고요. 163,840의 100승 정도가 되는 거죠. 바둑의 탐색 공간이 바둑에서 가능한 수의 숫자가 어마어마하게 많다고 하지만 그것보다도 훨씬 더 많을 겁니다.

이게 Kimi K2의 학습 loss를 제가 그래프를 체크해서 찍어봤는데 1.32 정도가 되는 것 같더라고요. 그러면 1.32가 어떤 의미냐면 perplexity라는 측면에서 보면 3.7 정도가 나오는데 이 3.7의 의미가 뭐냐 하면 토큰마다 선택지가 3.7개 있다고 보시면 될 것 같아요.

그러니까 원래 기본적으로 모든 토큰에 대해서 동일한 확률을 부여하면 163,840개의 선택지가 있는 거죠. 그런데 프리트레이닝을 통해서 선택지의 개수가 크게 줄어듭니다. 한 3.7개 정도에서 하나 뽑는 문제로 바뀌는 거예요.

그리고 이것은 전체 시퀀스에 대한 평균이니까 맥락이 주어지는 경우에는 선택지의 개수가 실용적으로 훨씬 더 줄어들게 되고 특히 뻔한 토큰들에 대해서는 더더욱 줄어들게 됩니다. 그러니까 약간 바벨의 도서관 같은 거죠.

<span class="paragraph-timestamp" data-ts="35:23">35:23</span> **노정석** 선택지가 줄었다는 게 결국 학습의 결과물로 수많은 랜덤 경로에서 어떤 정의되고 organized 된 경로들을 얘가 갖추기 시작했다는 말로 이렇게 해석해도 되는 거죠.

<span class="paragraph-timestamp" data-ts="35:31">35:31</span> **김성현** 네, 약간 바벨의 도서관 같은 느낌으로 생각할 수 있을 것 같습니다. 그러니까 가능한 모든 어떤 100개짜리 토큰의 시퀀스들이 탐색할 수 있는 경우의 수는 그 모든 조합을 생각하면 무궁무진하게 많죠.

그런데 그중에서 실제로 의미 있는 시퀀스들은 거기에 비해서 훨씬 적을 겁니다. 그러니까 대부분의 것들은 말이 안 되는 시퀀스들일 거고 그 토큰들을 무작위로 늘어놓으면 대부분 말이 안 되는데 그중에서 말이 되는 것들은 지극히 소수인 거죠.

프리트레이닝을 통해서 그 지극히 소수의 가능성들, 경우의 수들을 추려내는 거라고 볼 수 있습니다.

<span class="paragraph-timestamp" data-ts="36:10">36:10</span> **노정석** 말이 되는 의미 있는 경로들을 얘가 학습하는 거라고 생각해야 되는 거죠. 성현님, 여기서 왜냐하면 저희 vocabulary size, cross-entropy loss의 의미, 사실 거기서 도출되는 perplexity의 개념 이것을 좀 청중분들이 너무 여기서 갭이 좀 크실 것 같아서 이것을 간단하게만 recap하면 어떻게 얘기하면 좋을까요?

## LLM의 학습과 Perplexity의 의미    *36:25*

<span class="paragraph-timestamp" data-ts="36:32">36:32</span> **김성현** 조금 더 설명을 붙이자면 LLM이 보통 다음 토큰 예측으로 학습된다고 많이 표현을 하잖아요. 그런데 다음 토큰 예측의 실질적인 의미가 무엇이냐면, 아주 간단한 단어를 생각해 보면 될 것 같습니다. 그러니까 다음 단어 예측이라고 생각을 해볼게요.

그러면 어떤 문장 다음에 나올 수 있는 단어는 단어의 숫자가 있겠죠. 사전에 있는 단어의 숫자가 될 겁니다. 그 사전에 있는 모든 단어들 중에 하나를 예측하는 문제가 되는 거죠.

그게 일종의 분류 문제가 됩니다. 그중에서 정답 단어를 선택하는 문제. 그러면 가능한 단어의 숫자가 vocabulary, 보통 vocabulary라고 표현하는 어휘의 수가 됩니다. 그러니까 선택지의 숫자인 거죠.

선택지의 숫자가 Kimi K2의 경우에는 163,840개입니다. 그중에서 하나를 찍어야 되는 거죠.

<span class="paragraph-timestamp" data-ts="37:18">37:18</span> **노정석** 표현할 수 있는 단어의 숫자가 163,840개.

<span class="paragraph-timestamp" data-ts="37:25">37:25</span> **김성현** 그리고 163,840개를 한 번만 예측한다고 되는 게 아니라 여러 번 예측해 나가야 하는 거죠. 그렇기 때문에 가능한 경우의 수는 그것의 제곱 배로 계속 늘어나게 됩니다. 어마어마한 숫자가 되는 거죠.

그런데 모델을 다음 단어 예측에 대해서 학습을 시키면 그 학습하는 loss, cross-entropy가 결국은 그 예측을 얼마나 정확하게 하는가에 대한 loss가 됩니다. 이 예측을 더 잘하게 되도록 학습을 시키는 거죠.

그런데 이 학습을 하고 있는 loss에 대해서 exponential로 하면 그게 약간 좀 더 직관적으로 그 값을 이해할 수 있는데 그 직관적인 이해 방식 중 하나가 이 loss에 대해서 exponential을 취한 이 숫자, 이 숫자 중 한 개를 찍는 확률이라고 보면 됩니다.

163,840개를 선택지로 두고 찍는 문제에서, 그것을 동등하게 두고 찍는 문제에서 3.7개 정도의 단어를 두고 그중에서 하나를 찍는 문제로 바뀐다, 이렇게 생각할 수 있을 것 같아요. 가능한 경우의 숫자가 엄청나게 줄어드는 거죠.

<span class="paragraph-timestamp" data-ts="38:31">38:31</span> **노정석** 맞습니다. 그래서 제가 청중들에게 전달하고 싶었던 것은 어떤 이 숫자의 의미보다 loss나 perplexity나 이런 것을 어떻게 하면 쉽게 설명해 드릴 수 있을까였는데,

<span class="paragraph-timestamp" data-ts="38:45">38:45</span> **최승준** 네, 그런데 지금 슬라이드를 잠깐 청취자분들이 멈춰 놓고 캡처를 한 다음에 GPT-5에게 물어보면 좋습니다.

<span class="paragraph-timestamp" data-ts="38:51">38:51</span> **노정석** 네, 맞습니다. 그래서 이것이 굉장히 어려운 기초 내용들과 오랫동안 학습해야 하는 그런 머신러닝, 이 LLM의 이런 부분들을 다 포함하는 내용이기 때문에 직관적으로 LLM 자체가 이 넓은 가능성의 공간에서 무언가를 매우 정리된 형태로 정리해서 가짓수를 줄여주는 그 과정이 학습이다, 라고 매우 요약해서 말씀하신 것으로 이해해 주시면 될 것 같습니다.

## 추론의 분기점: Entropy가 높은 토큰    *39:17*

<span class="paragraph-timestamp" data-ts="39:17">39:17</span> **김성현** 프리트레이닝을 통해서 말도 안 되는 토큰들은 다 쳐내고 선택지를 줄여주는 거죠.

그래서 실제로 모델이 추론할 때 어떤 일이 일어나는지를 보면, 여기서 파란색은 모델의 entropy, entropy라고 표현하는데 불확실성이라고 표현할게요. 불확실성이 낮은 겁니다.

이 토큰들에 대해서는 모델이 거의 확신을 하고 있어요. 파란색이 파랄수록 더 확신을 하고 있는 거고요. 붉은색으로 가면 entropy가 좀 높은, 불확실한 겁니다.

거의 대부분의 토큰들은 다 파란색이에요. 그러니까 프리트레이닝을 통해서 이 토큰들에 대해서 모델이 거의 확신을 하고 있는 거죠. 말하자면 이 부분들을 예측하는 것은 어렵지 않은 겁니다.

그래서 약간 소수의 이 빨간색 토큰들, 이 부분들에 대해서만 잘 예측하면 나머지는 거기에 대해서 그대로 따라오는 거죠.

<span class="paragraph-timestamp" data-ts="40:09">40:09</span> **노정석** 저 entropy가 높은 구간이 그러면 어쩌면 이것이 결정적인 분기점이라고 받아들여도 될까요?

<span class="paragraph-timestamp" data-ts="40:18">40:18</span> **김성현** 네, 그렇게 보고 있습니다. 요즘 이 부분들이 추론 내에서 가장 중요한 토큰들이다.

그래서 잘 보면 이것이 흐름을 약간 바꾸는 토큰들이에요. 그러니까 이런 기본적인 계산 같은 것들은 계산은 그대로 쭉쭉쭉 이어지는 거고, 사칙 계산 같은 것 쭉 이어지는 거고요.

그중에서 '생각을 바꿔볼까?', '이렇게 생각해 볼까?' '그렇다면 어떨까?' 이런 식으로 의외로 이런 수치 수학 계산 같은 부분들은 모델이 불확실성이 적고요.

불확실성이 높아지는 부분, 예측의 가치가 있는 부분들은 이렇게 생각의 흐름을 바꾸는 토큰들입니다. 분기를 나눠주는.

<span class="paragraph-timestamp" data-ts="40:53">40:53</span> **최승준** maybe 같은 거 보이고 뭐 이런 거 보이고 그러네요.

<span class="paragraph-timestamp" data-ts="40:59">40:59</span> **김성현** 네, 결론을 낸다거나 이런 부분들이 의외로 이런 토큰들이 불확실성이 높습니다.

그러니까 사람들이 생각하면 숫자 이런 것들을 계산하는 것은 굉장히 어렵고 불확실할 것 같고 이런 평이한 토큰들은 쉽게 할 것 같은데 오히려 평이한 토큰에 대해서 그것이 갈림길이 되기 때문에 불확실하다고 표현하면 부정적일 것 같긴 한데 갈림길의 어떤 기점이 되는 거죠, 그 토큰이.

<span class="paragraph-timestamp" data-ts="41:25">41:25</span> **최승준** 그것이 내부 표현 자체는 아니기 때문에 그냥 토큰으로 드러난 것이지 내부 표현을 보면 또 되게 의미심장할지도 모르는 거잖아요.

<span class="paragraph-timestamp" data-ts="41:32">41:32</span> **김성현** 네, 그럴 수도 있습니다. 그리고 이것들이 어떤 중요한 분기라고 생각하고 있을 수 있죠. 모델 자신이 이 상황에서 예를 들어서 사고를 전환해야 할 때 이 상태에서 사고를 전환할까 아니면 그냥 이대로 쭉 갈까 이런 부분들이 결정되는 순간이라고 볼 수도 있겠죠.

<span class="paragraph-timestamp" data-ts="41:47">41:47</span> **노정석** 그래서 이 수많은 토큰들에 대해서도

<span class="paragraph-timestamp" data-ts="41:52">41:52</span> **김성현** 대부분은 자동적으로 예측되기 때문에 실제 탐색 공간은 정말 얼마 안 되는 겁니다. 실제 탐색해야 하는 것은 이런 몇 가지 붉은색 토큰들이라고 볼 수 있죠.

<span class="paragraph-timestamp" data-ts="41:59">41:59</span> **노정석** 결정적인 '그런데 말입니다'라고 하는 그런 토큰들이 있는 거네요. 네.

## 집단적 추론의 학습: 인터넷 포럼 사례    *42:04*

<span class="paragraph-timestamp" data-ts="42:08">42:08</span> **김성현** 그리고 이것이 프리트레이닝 과정에서 어떻게 학습됐을까 하면 여러 가지 가능성, 여러 가지 사례가 있을 텐데 저는 굉장히 재미있게 봤던 것 중 하나가 포럼입니다. 인터넷 포럼, 이것이 어떤 songoku라는 사용자가 자기 숙제를 들고 왔는데

보통 인터넷 포럼들을 보면 '숙제는 안 풀어준다' 이런 규칙이 있는 경우가 많잖아요. 그리고 숙제에 대해서 그냥 답만 내주는 것을 피하는 경향이 좀 있죠.

그것 때문인지 이 BvU라는 유저가 답에 대해서 답은 직접 주지 않습니다. 그런데 자꾸 생각하게 해요.

이 사례에 대해서 생각해 보는 건 어때 이렇게 생각해 보는 건 어때 이런 식으로 계속 피드백을 줍니다. 그러니까 이 원 유저가 생각해 보니까 여기서 뭐 내가 실수한 것 같네, 이게 맞나, 이게 맞나 뭐 이런 얘기들을 합니다.

전형적으로 저희가 추론 모델에서 보는 패턴이죠. 추론 모델은 생각하다가 이 사례에 대해서 생각해 보면 어떨까 생각하다가 어, 그럼 내가 뭔가 실수했나 돌이키고 이런 패턴들이 추론 모델로 나타나잖아요. 이런 데이터가 인터넷에 거의 없는데 포럼 같은 데서 가끔 이렇게 등장하는 겁니다.

그리고 더 놀라운 건 이게 한 사람이 쓰는 거 아니죠? 한 명의 사람이 자기가 딱딱딱 문제에 대해서 이런 중간 과정을 풀어서 이렇게 요약한 게 아니라 여러 명의 사람들이 참여하면서 상호작용하면서 이런 어떤 집단적인 추론의 데이터가 만들어진 거죠.

<span class="paragraph-timestamp" data-ts="43:32">43:32</span> **노정석** 얼마 전에 그 Andrej Karpathy가 자기가 Eureka Lab을 창업한 이유에 대해서 그 Dwarkesh 팟캐스트에 나와 가지고 비슷한 얘기를 했던 것 같아요. 나의 perplexity를 다 알고 있는 완벽한 조교가 있으면 학습 효율이 어마어마하게 증가한다. 자기는 그걸 만들 거다라는 얘기를 했었는데 이 기시감이 있네요. 내 수준에 딱 맞는 조교

<span class="paragraph-timestamp" data-ts="43:50">43:50</span> **김성현** 그리고 다양한 사람들이 상호작용하면서 다양한 사람들의 상호 작용의 결과가 일종의 추론의 기록이 되는 거죠. 글을 통해서 정답으로 도달하는 그래서 굉장히 익숙한 추론 토큰들이 여기 이 사례에서 등장을 합니다. 그리고 이것들이 이렇게 드물지만 존재하는 사례가 LLM이 추론하는 능력을 배운 데이터가 되겠죠.

## 강화 학습을 통한 추론 능력의 발현    *44:14*

<span class="paragraph-timestamp" data-ts="44:20">44:20</span> **김성현** 그러면 이 능력을 어떻게 꺼내 올 것인가가 문제가 됩니다. 대부분의 경우는 파묻혀 있어서 이게 잘 드러나지 않아요. 드러날 확률이 0은 아니지만 추론하지 않을 확률이 훨씬 높습니다. 이 부분에 대해서 최근에 재밌는 논문이 나와서 그 논문의 어떤 직관 설명을 드릴게요.

추론을 생성할 확률이 있고 추론했을 때 답이 맞을 확률이 있습니다. 추론을 생성하지 않을 확률이 있습니다. 그리고 추론을 하지 않고 답이 맞을 확률이 있습니다.

그랬을 때 LLM은 기본적으로 추론을 하지 않을 확률이 훨씬 높습니다. 근데 추론을 했을 때 답이 맞을 확률이 높습니다. 추론을 하지 않았을 때보다 그러니까 대체로 추론을 생성하지 않지만 추론을 생성했을 때 답이 맞을 확률은 추론을 생성하지 않고 답이 맞을 확률보다는 높은 거죠. 이게 이런 비대칭적인 상황인 겁니다.

그런데 그러면 강화 학습의 과정에서 이게 어떤 식으로 작용하냐면 추론을 생성할 확률은 낮지만 추론이 생성될 확률에 비해서 정답일 확률은 높습니다. 강화 학습은 정답인 경우에 확률을 높여주는 거잖아요. 그러면 추론을 생성한 사례가 강화를 받겠죠.

<span class="paragraph-timestamp" data-ts="45:22">45:22</span> **노정석** 계속 말을 길게 하도록 인센티브를 거는 방향인 거네요.

<span class="paragraph-timestamp" data-ts="45:30">45:30</span> **김성현** 예, 그 방향으로 작용하게 됩니다. 그러니까 비대칭적이니까 추론을 한 경우에 좀 더 주목을 하는 거죠. 그때 답이 맞을 확률이 더 높으니까요.

추론할 확률이 굉장히 낮더라도 그 낮은 확률에 비해서 정답인 경우가 많으니까 그 정답에 대해서 더 부각되는 거죠.

강화 학습에 대해서는 강화 학습은 정답이냐 아니냐만 보니까요. 그러니까 정답을 가지고 평가하는 것 자체가 확률이 낮더라도 정답인 경우가 많으면 그 등장하는 확률보다 보상 강화를 더 강하게 받는 거죠.

<span class="paragraph-timestamp" data-ts="45:59">45:59</span> **노정석** 네, 그러니까 아까 그 perplexity 관점에서 볼 때 그냥 단순히 토큰에 들어가는 그러니까 compute가 많아지면 많아질수록 결국은 된다 뭐 이런 얘기로 요약할 수 있는 거죠. 심하게 요약하면

<span class="paragraph-timestamp" data-ts="46:12">46:12</span> **김성현** 사실은 그보다 좀 더 좋은 결과입니다. 이 논문의 의도에 따르자면 pre-training에서 이런 패턴을 학습하는 것에 비해서 강화 학습은 이게 굉장히 빠르게 일어난다고 얘기를 합니다.

그러니까 이 단계별로 각 단계별로 등장 확률이 높아지는데 정답일 가능성이 높지만 등장 비율이 낮은 어떤 추론하는 시퀀스, 어떤 응답이 있다면 그 응답의 확률이 높아지는데 지수적으로 높아진다고 표현을 합니다.

기하급수적으로 늘어나는 것이죠 그래서 각 단계마다 기하급수적으로 늘어나기 때문에 굉장히 빠르게 능력이 학습됩니다.

<span class="paragraph-timestamp" data-ts="46:55">46:55</span> **노정석** 그러니까 저희 그 tech paper들을 보면 pre-training 모델을 그 pre-training부터 post-training까지 해서 밖에 릴리스하는 데 들어가는 compute를 100으로 보면 거의 90 이상이 pre-training에 쓰이고

나머지 10% 언더가 post-training에 쓰이는 건데 사실 pre-training에서 봤던 것들은 아까 성현 님이 말씀하신 것처럼 수많은 가능성에서 그 갈래를 잘 찾는 것들이 훈련이 덜 된 상태인데

RL을 통해서 그걸 좀 발현시켜 주면 얘가 적은 compute를 투입함에도 불구하고 얻게 되는 결과물의 품질이 그런 게 어마어마하게 빨리 높아진다 이렇게 보면 되는 거죠.

<span class="paragraph-timestamp" data-ts="47:29">47:29</span> **김성현** 예를 들어서 pre-training에 대해서는 말씀드렸던 것처럼 추론 없이 정답만 내놓는 경우가 대부분이기 때문에 그 확률이 계속 높고 추론을 통해서 정답을 내놓는 확률은 굉장히 낮은 거죠.

근데 추론을 통해서 정답을 내는 경우가 정답일 확률이 높으니까 강화 학습의 현장에서는 그 부분이 비대칭적으로 보상을 더 크게 받습니다.

강화를 크게 받습니다.

강화 학습을 거칠 때마다

<span class="paragraph-timestamp" data-ts="47:55">47:55</span> **최승준** 여기서 강화를 받는 건 결국에는 CoT를 뱉는다는 액션이 강화된다는 거죠. 거기에 어느 정도 이점을 준다는 거잖아요

<span class="paragraph-timestamp" data-ts="48:00">48:00</span> **김성현** CoT를 하지 않는 것에 비해서 CoT를 하는 쪽이 더 강화를 강하게 받는 거죠. 실제 CoT를 할 확률에 비해서 실제 할 확률은 1%밖에 안 되는데 강화는 예를 들어서 한 2% 정도의 수준으로 받는다고 볼 수 있습니다. 그럼 1이 2가 되는 거죠. 그러면 2가 다시 4가 되고 4가 8이 되고 이런 식으로 빠르게 늘어나는 겁니다.

<span class="paragraph-timestamp" data-ts="48:21">48:21</span> **최승준** 빠르게 기하급수적으로 올라간다

<span class="paragraph-timestamp" data-ts="48:23">48:23</span> **김성현** 그렇기 때문에 진짜 pre-training에 대해서는 pre-training을 거친 것만으로는 CoT가 생성될 확률이 굉장히 낮고 그건 계속 낮게 유지되겠지만

강화 학습에 의해서 그것이 굉장히 빠르게 그리고 굉장히 주류적인 패턴이 되는 겁니다.

실제로 비교적 적은 연산, compute만으로도 이렇게 되기 때문에 강화 학습을 통해서 굉장히 낮은 확률을 가지고 있었던 pre-training된 모델이 굉장히 낮은 확률을 가지고 있었던 추론하는 패턴이 급격하게 부상하게 되는 거죠.

<span class="paragraph-timestamp" data-ts="48:52">48:52</span> **최승준** 그러면 모델이 응답하는 그 분포 자체가 이동했다고 볼 수 있는 건가요?

<span class="paragraph-timestamp" data-ts="48:59">48:59</span> **김성현** 네, 이동하게 됩니다. 굉장히 빠르게 이동합니다. 점점 더 길어지는 패턴으로 이동하는 거죠

## 강화 학습은 기존 능력을 꺼내는 것일까?    *49:01*

<span class="paragraph-timestamp" data-ts="49:04">49:04</span> **노정석** 그러니까 이게 참 철학적인 질문을 조금 할 수밖에 없는데 그럼 강화 학습을 통해서 얘가 정답 맞히는 능력이 진짜 함양되는 게 아니라 이미 그 말을 길게 함으로써 정답을 맞힐 확률을 증가시키는 그 성향이 계속해서 보상을 받아왔다고 요약해도 그런 식으로도 좀 들리기도 하네요.

<span class="paragraph-timestamp" data-ts="49:25">49:25</span> **김성현** 이 부분에 대해서 말씀드리자면 추론을 생성해서 답을 맞히는 것이 일반화 가능한 능력인 거죠. 추론을 생성하지 않고 답을 맞힐 확률은 물론 다 그런 건 아니지만 대체로 암기에 의한 가능성이고 그래서 정답일 확률이 낮은 거죠.

그러면 일반화 가능한 패턴으로 모델이 나아가는 겁니다.

일반화 불가능했던, 자기가 암기해서 알고 있던 것으로 응답하던 패턴에서 일반화 가능한 능력의 방향으로 나아가는 겁니다. RL을 통해서

<span class="paragraph-timestamp" data-ts="49:54">49:54</span> **노정석** 그리고 그런 방향들이 인센티브를 받고 계속 그런 성향이 강해지도록 파라미터가 계속 업데이트되는 게 이제 post-training인 거죠.

<span class="paragraph-timestamp" data-ts="50:05">50:05</span> **김성현** 그래서 이렇게 생각하면 있던 능력을 꺼내오는 거 아니냐는 게 질문이 바로 따라 나오죠. 이것도 계속 논쟁이 되고 있는 주제이기는 한데요.

그러니까 결국은 그런 추론하는 능력이 pre-training 과정에서 학습된 거고 그 추론하는 능력을 가져오는 거 아니냐 이 질문이 나오게 되죠. 계속 논쟁이 되고 있는 부분이긴 합니다만 그렇게만 볼 수 없는 지점들도 같이 있긴 합니다.

pre-training을 통해서 계속 반복돼서 나오는 이야기지만 수학을 가지고 추론하는 능력을 가르쳤더니 시를 쓰는 데도 추론을 하더라 이렇게 다른 영역으로 확장되는 게 있고 그게 또 pre-training의 한 가지 역할이기도 합니다.

pre-training을 통해서 다양한 영역들이 연결되어 있기 때문에 그 연결된 다른 영역들에 대해서 일반화가 되는 거죠. 이것이 이제 한 가지 확장이라고 볼 수 있을 거고 또 최근에 나오는 이야기 중 하나는 조합하는 능력이 생긴다는 얘기도 합니다.

예를 들어 추론 과정에 대해서는 A 문제를 푸는 능력, B 문제를 푸는 능력 이런 게 있다고 하면 A 문제를 푸는 능력과 B 문제를 푸는 능력을 결합해서 어떤 새로운 문제를 푸는 능력이 추론 과정에서 발생하는 거죠. 그런데 이 과정에 대해서 학습을 하면 A라는 방법, B라는 방법을 더해서 C라는 방법을 결합하는 능력이 생긴다는 이야기도 합니다.

그러니까 기존에 가지고 있었던 부분적인 능력들을 조합해서 새로운 조합을 만들어서 문제를 푸는 능력이 발생한다는 이야기도 요즘 나오고 있습니다. 이런 일반화도 가능하다는 이야기도 나오고 있고요.

Kimi K2에 대해서도 한 가지 이야기가 나왔던 게 Kimi K2가 한 번의 지시에 대해서 2~300개의 도구를 사용하는 능력을 배웠다고 하잖아요. 그런데 어떤 사람들이 이야기하기로는 그런 능력 자체도 이런 식으로 창발됐다는 이야기도 합니다. 그러니까 도구를 사용하는 능력이 점점 더 창발되어서 더 많은 도구를 조합하는 능력이 창발될 가능성도 있다는 이야기도 하고 있습니다.

<span class="paragraph-timestamp" data-ts="51:57">51:57</span> **최승준** 슬라이드에서 보이는 합성 함수를 보니까 람다 캘큘러스 생각이 나네요. 결국 이게 합성 함수를 쓴다는 것 자체가 컴퓨테이션에서 굉장히 중요한 의미를 가지고 있잖아요.

<span class="paragraph-timestamp" data-ts="52:13">52:13</span> **김성현** 예, 어떤 기본적인 능력은 또 발생할 수 있는가, 이 문제는 또 다른 문제겠지만 기본적으로 갖고 있던 능력들을 새롭게 조합하고 더 길게 조합하는 능력들이 강화 학습에 의해서 발생한다고는 이야기도 하긴 합니다. 그런데 그게 어떻게 발생하는지는 앞으로 좀 더 연구가 되어야겠죠. 흥미로운 주제라고 생각합니다.

## 성공적인 강화 학습을 위한 조건    *52:26*

<span class="paragraph-timestamp" data-ts="52:26">52:26</span> **김성현** 앞서 나왔던 이야기들을 다 종합해 볼게요. 조금 흐름이 여러 갈래로 나뉘었다고 느끼셨을 수도 있을 것 같은데 이걸 한번 다시 정리해 보자면, 분산되었던 걸 요약해 보자면

앞서 나왔던 이야기, 모델이 일반화를 할 수 있게 하려면 모델에게 모델이 풀 수 있는 문제를 줘야 한다, 이게 한 가지 중요한 아이디어였죠.

그리고 그것은 일반화할 수 있는 방식으로 문제를 풀 수 있게 해줘야 한다는 말로 이야기해도 됩니다. 모델이 풀 수 있는 방식으로요. 그러니까 모델이 풀 수 있는 역량 내에서 문제를 제공해야 한다는 거죠.

그리고 on-policy여야 합니다.

왜 on-policy냐고 하면 off-policy의 경우에는 어떤 전문가가 문제를 풀었다고 하면 그 전문가가 가지고 있는 능력은 모델이 갖고 있지 않을 수도 있잖아요. 그러면 앞서 보여드렸던 것처럼 무조건 B 경로만 보게 되는 것과 마찬가지입니다.

정작 모델이 할 수 있는 능력으로는 C 경로로 가야 하는데 C 경로로 가지 못하고 B 경로에 대해서만 학습을 하는 거죠.

그런데 모델이 자기 능력에 따라서 C 경로로 가게 되면 그 모델은 거기서부터 막히는 겁니다.

그렇기 때문에 모델이 할 수 있는 능력 내에서 문제를 풀게 하기 위해서는 on-policy여야 합니다. 모델이 직접 문제를 풀어보고 모델이 자기의 방식으로 문제를 푼 다음에 거기에 대해서 보상을 얻고 학습을 해야 하는 거죠.

어떤 다른 사람이 문제를 '이런 식으로 풀어라'라고 하는 가이드를 주고 그걸 가지고 학습하는 게 아니라요.

<span class="paragraph-timestamp" data-ts="53:56">53:56</span> **최승준** 자기 경험으로 시행착오를 겪어야 한다는 거죠.

<span class="paragraph-timestamp" data-ts="53:59">53:59</span> **김성현** 예, 그래서 그럴 때 일반화가 가능한 겁니다. 왜냐하면 모델이 풀 수 있는 능력 안에서 강화 학습을 한 거니까요. 만약 모델이 풀 수 없는 방식으로 문제를 푸는 게 아니라요. 그리고 풀 수 있다 없다 뿐만 아니라 모델이 선호하는 방식의 풀이 자체도 따로 있겠죠. 사람과는 다른, 그렇기 때문에 on-policy여야 합니다.

그리고 추론 과정에 구조를 부여하는 것, 예를 들어서 MCTS 같은 어떤 탐색 문제를 생각하면 거기에 대해서 각 단계를 쪼개고 그 단계에 대해서 구조를 부여하거든요. 그런데 그 어떤 특정한 구조를 부여하는 것도 사람의 아이디어이죠. 어떤 사람이라는 전문가가 보기에 '이 문제를 이렇게 풀어야 할 것 같아' 라고 하는 아이디어가 들어가는 거죠.

그런데 그것은 모델이 실제로 문제에 접근하고 풀 수 있는 능력과는 동떨어져 있을 수 있죠. 그렇기 때문에 구조를 부여하는 것도 불필요하거나 오히려 해로울 수 있는 겁니다.

그리고 앞서 보여드렸던 것처럼 저희가 프리트레이닝에서 굉장히 낮은 확률의 추론이지만 그 추론의 경로가 정답일 비율이 높기 때문에 확률이 급격하게 늘어나는 이야기를 말씀드렸잖아요. 이 과정에서 중요한 건 정답을 정답이라고 정확하게 판단해 줘야 하는 게 필요한 겁니다.

그러니까 추론하지 않고 그냥 암기해서 푸는 이런 부분들에서 오답이 많이 발생할 그런 부분에 대해서는 정답이 아닌 경우에 오답이라고 해주고, 추론을 통해서 일반화 가능한 방식으로 문제를 제대로 풀었을 경우에, 그리고 그때 정답을 맞혔을 경우에 그런 경우에만 정답을 정답이라고 보상을 줘야 하는 거죠.

오답을 정답이라고 피드백을 주면 안 되는 겁니다. 그래야 일반화 가능하지 않은 패턴이 잘못 강화되는 것을 막을 수 있을 테니까요.

<span class="paragraph-timestamp" data-ts="55:39">55:39</span> **최승준** 지난 세션에서 false positive 이야기하셨을 때 그 이야기인 거죠.

<span class="paragraph-timestamp" data-ts="55:46">55:46</span> **김성현** 상대적으로 일반화 가능한 패턴들이 정답을 정확하게 판단해 주는 것을 통해서 상대적으로 더 강화되게 되는 거죠. 이런 조건들이 갖춰져야 하는 겁니다.

추론에 대해서 정답을 좀 가혹하게 판단하는, 완전히 정답이 일치할 때 일치할 때만 정답이라고 판단하는 것들이 있다고 봤을 때, 그런 것들이 있었다고 하면 오답을 정답이라고 주는 경우는 일단 없다고 생각하겠습니다. 그러면 그때 보상을 상대적으로 많이 받는 건 일반화 가능한 경우에만 보상을 많이 받는다고 보시면 될 것 같습니다.

그러니까 일반화 가능한 방식으로 CoT를 한 다음에 정답을 내는 경우와 CoT 없이 정답을 내는 경우를 보면 일반화 가능하지 않은 경우에는 오답이 많겠죠. 그러면 그 오답 때문에 그 부분의 비율은 줄어들 거고, 정답을 잘 내는, 일반화 가능하게 다양한 문제들에서 정답을 내는 어떤 행동 패턴은 상대적으로 더 강화를 크게 받겠죠. 왜냐하면 정답을 정답이라고 정확하게 판단하니까요.

일반화 가능하지 않은데 어떤 답을 냈을 때 그 답을 잘못 정답이라고 봐서 그걸 강화시켜주는, 일반화 가능하지 않은 어떤 행동 양식을 행동 양식의 강화를 제공하지 않는 역할을 정확한 피드백이 하는 거죠. 그러니까 문제를 찍어서 맞히는 걸 억제하는 거죠. 정답을 정확하게 봐주면 찍어서 맞히는 경우가 상대적으로 억제되는 거죠.

그런데 정답을 정확하게 판단하지 못하면 상대적으로 찍어서 맞히는 경우가 강화를 받을 확률이 높아지겠죠. 그러면 일반화 가능한 패턴이 부상하는 데 방해가 되는 거라고 생각할 수 있습니다.

그러니까 이 정확한 피드백을 주는 것이 일반화 가능한 패턴을 발견하는 데 도움이 된다, 네, 그렇게 볼 수 있습니다.

## DeepSeek R1의 추론 학습 방식    *57:27*

<span class="paragraph-timestamp" data-ts="57:30">57:30</span> **김성현** 그래서 DeepSeek R1으로 다시 넘어오면 DeepSeek R1의 방식은 아주 간단했습니다. 프롬프트를 보면 '추론 과정을 수행한 다음에 사용자에게 응답을 제공해라. 추론 과정은 태그 안에 넣고 응답은 로 감싸라.'

그리고 보상은 에서 나온 응답이 정답과 맞는지 그걸 판단하는 것만 했고, 내에서는 라는 태그로 감싸라, 이것에 대해서는 보상이 걸렸지만 내에 어떤 것이 들어가야 하는지에 대해서는 아무런 터치가 없었습니다. 손대지 않은 것이죠.

그리고 이것만으로 추론이 발생했습니다.

<span class="paragraph-timestamp" data-ts="58:02">58:02</span> **최승준** 이게 재밌는 게 Anthropic에서 벌써 한 1년 전이었나, 그때도 라는 그 XML 태그가 있었거든요. 그래서 유저들이 그것을 나중에 발견하고서는 그것만 드러내는 작업 같은 걸 하기도 했었거든요. 추론 모델을 공식 발표하기 전에도.

<span class="paragraph-timestamp" data-ts="58:19">58:19</span> **김성현** 그것은 아마 그때 어떻게 포스트 트레이닝이 되었는지는 모르겠지만 그때도 CoT 같은 것들을 학습을 하긴 했기 때문에 그렇죠. 다만 그때의 방식은 좀 달랐을 수도 있습니다.

왜냐하면 CoT를 학습할 수 있는 방법 중 하나는 그냥 전문가, 즉 사람이 '이런 식으로 생각해라'라고 써주는 방식도 있을 수 있긴 하거든요. 실제로 그렇게 많이 학습했었고요.

그래서 그 CoT가, 라는 CoT가 실제로 강화 학습을 통해서 학습이 되어서 그 안의 내용을 터치하지 않은 건지, 내용을 터치했다면 얼마나 터치했는지는 알 수 없습니다. 그렇지만 그때도 CoT 같은 것들이 존재했었죠.

그리고 사소한 영향이긴 한데, Anthropic이 XML이나 HTML 태그를 쓰는 걸 선호합니다. 예, 그래서 DeepSeek에서도 이런 태그를 쓰는 방식을 선택한 것 같기도 합니다.

여하간 다시 요약하자면, 모델이 스스로 어떤 전문가의, 자신이 자신에게 없는 능력을 통해서 문제를 푸는 것이 아니라 자신이 풀 수 있는 방식대로 문제를 풀고 그 문제를 푼 다음에 그 정답을 통해서 피드백을 받는 것이 추론을 등장하게 하는 경로였다고 할 수 있을 거고, 그 부분에 대해서 많은 개념들이 들어왔습니다.

많은 개념을 결부시켜서 생각해 볼 수 있습니다. on-policy하고 off-policy를 생각할 수 있고요.

이제 일반화와 오버피팅의 문제, 모델이 풀 수 있는 문제를 주었을 때에만 풀 수 있는 형태로 제공했을 때에만 일반화가 발생할 수 있다는 것, 이런 부분들이 들어왔고 이런 부분들을 통해서 왜 추론이 발생할 수 있었는지, 왜 추론이 강력한 일반화를 가능하게 하는지, 그리고 그 과정에서 pre-training의 역할은 무엇인지 이렇게 결합시켜서 생각해 볼 수 있을 것 같습니다.

이전에 했던 것처럼 마지막 슬라이드에서 뜬구름 잡는 Jason Wei가 한 얘기이기 때문에 뜬구름 잡는 얘기라고 평가하면 안 되겠지만 완전히 다른 주제이긴 한데요. on-policy, off-policy에 대해서 Jason Wei, OpenAI에 있다가 지금 Meta로 간 연구자인데 그 사람이 한 얘기가 있습니다.

## 마무리: On-policy RL과 인생: Jason Wei의 이야기    *1:00:05*

<span class="paragraph-timestamp" data-ts="1:00:12">1:00:12</span> **김성현** 사람도 보면 처음에는 모방하는 것으로 학습하죠. 선생님이 가르친 대로 학습한다거나 자기가 생각하기에 좋아 보이는 사례들을 가지고 그걸 모방하려고 학습을 많이 하게 됩니다.

그런데 사람도 결국은 갖춘 능력이 다 다르잖아요. 갖춘 능력이 다르고 자기가 주어진 조건은 다 다르죠.

그 주어진 조건에 대해서 성공적인 선택을 하기 위해서는 더 이상 모방할 수 없는 영역, 지점이 있고 그 모방할 수 없는 지점에서 on-policy를 할 수밖에 없다. 스스로 시도해 보고 거기에 대해서 경험을 얻고 보상을 얻을 수밖에 없다. 그런 얘기를 합니다.

결국 사람도 약간 비슷한 딜레마가 늘 있는 거죠. 모두가 딱 모방할 수 있는 대상이 있어서 그걸 복제하면 좋을 텐데 처한 환경과 능력은 다 다르기 때문에 그 환경과 능력 사이에서 정말로 일반화 가능한 패턴을 위해서는 스스로 행동하는 것을 통해서 경험을 얻을 수밖에 없는 것 같다는 얘기를 합니다.

그리고 그것이 이제 모방을 뛰어넘어야 되는 이유이기도 하죠. 그래서 늘 on-policy, off-policy 얘기를 하다 보면 이 이야기가 생각이 나서 마무리로 가져와 봤습니다.

<span class="paragraph-timestamp" data-ts="1:01:15">1:01:15</span> **노정석** 참 재밌네요. 재밌어요.

<span class="paragraph-timestamp" data-ts="1:01:19">1:01:19</span> **최승준** 이게 이제 교육에 대해서 할 말이 여기에 연결돼서 굉장히 많이 있죠.

<span class="paragraph-timestamp" data-ts="1:01:22">1:01:22</span> **노정석** 맞아요. 사실 우리네 인생 자체가 on-policy RL이죠. 보상이 떨어지는 게 예쁜 여자친구를 사귄다든지, 돈을 많이 번다든지, 아니면 어디 가서 상을 받는다든지 돈과 명예 이런 형태로 보상 함수가 사회에 짜여 있는 거고 그리고 그러한 explicit한 보상 함수 말고 스스로 자기 안의 structure에서 보상 함수를 더 상위적인 가치로 짜내는 사람들이 위대한 방향으로 나아가는 것 같고 그렇습니다.

사실 성현님, 저희가 오늘 이게 제가 이 대화를 하면서도 제 머릿속에서 성현님이 말씀하시는 이 다음 토큰을 계속 따라가는 데 소위 난이도가 굉장히 높았거든요. 다음 토큰이 나오는 데 perplexity가 굉장히 높았다.

저도 그렇게 생각하는데 저희가 audience에게 도움이 될 것들을 조금은 더 제공을 해야 될 것 같아요.

<span class="paragraph-timestamp" data-ts="1:02:13">1:02:13</span> **최승준** 그 관점에서 제가 몇 가지 질문을 좀 드려보겠습니다.

사실 LLM하고 RL하고 어떻게 연결할 생각을 했는지부터가 초보자들은 제가 그랬거든요.

왜 정책이자 action, actor가 LLM이냐, 그리고 그러려면 LM이 확률을 뱉어내야 되고, 취해야 되는 action, next token prediction이 있고,

상태라는 context가 있고, 이런 notion 자체가 사실은 처음에 좀 많이 어려워요.

그러니까 LLM도 알고 RL도 어느 정도 알더라도 그 가교를 만드는 작업 자체를 지금 다 퉁치고 넘어갔거든요.

<span class="paragraph-timestamp" data-ts="1:02:50">1:02:50</span> **노정석** 오늘 그 가교에 해당하는 부분들을 성현님이 pre-train phase에서 모델은 어떤 것들을 가지고 있는가에 대해서 사실은 비유를 들어서 너무 잘 말씀해 주셨고 RL이 거기에서 어떤 성향, 그런 뭐라고 해야 할까, propensity라고 해야 할 것 같은데 그런 성향을 높이는 데에서 RL의 어떤 근본적인, 얘가 하는 일은 뭐냐라는 거를 너무 좀 딱 짚어주셨거든요.

<span class="paragraph-timestamp" data-ts="1:03:12">1:03:12</span> **최승준** 그런데 제대로 하려면 SARSA부터 해가지고 그런 수식들을 다 주워 담아야 되는데 그게 너무 어려워지죠.

<span class="paragraph-timestamp" data-ts="1:03:23">1:03:23</span> **노정석** 그렇죠. 그런데 RL도 이제 그런 거 안 해도 되지 않을까요? Q-learning, SARSA, TD 해서 그 수식들 다 배우고 그다음에 policy gradient 공부시키고 이렇게 하는데 그 앞에 있는 것들을 싹 없애고 이제 policy gradient 이론이 이거다, 이걸 maximize하게 한다라고 거기서 출발하면 맞을 것 같아요.

<span class="paragraph-timestamp" data-ts="1:03:39">1:03:39</span> **최승준** 거기서 출발하는 게 좋을 것 같긴 해요, 사실.

<span class="paragraph-timestamp" data-ts="1:03:41">1:03:41</span> **김성현** 그중에서도 사실 policy gradient도 REINFORCE 정도만 보면 거의 LLM엔 충분하니까요

<span class="paragraph-timestamp" data-ts="1:03:52">1:03:52</span> **노정석** 맞아요. 예, 그 부분만 나중에 살짝 빼서 성현님한테 거기를 좀 더 cover해 달라고 하는 것도 도움이 많이 될 것 같습니다.

<span class="paragraph-timestamp" data-ts="1:04:03">1:04:03</span> **최승준** 맞아요. 저도 그게 기대가 됩니다. 또 미션이 생기셨네요. 그래도 재밌는 부분을 많이 짚어주셔서 초반부에는 어려운데 사실 후반부로 가면 이렇게 막 쏙쏙 들어왔어요. 초반부에는 잘 못 따라왔었는데.

<span class="paragraph-timestamp" data-ts="1:04:15">1:04:15</span> **노정석** 맞습니다. 예, 성현님 말씀을 들으면서 아까 cross-entropy, perplexity와 이게 쭉 머릿속에서 저도 많은 또 지향점이 생겨서 끝나고 나면 이제 LLM에게 물어봐야 할 것 같아요.

모델과 함께 학습을 해야 될 것 같습니다.

그러면 오늘 어려운 내용이었는데요. 성현님, 이 부분을 최대한 간략하고 하나의 완결된 스토리텔링으로 만들어주신 이 엄청난 노력에 정말 감사드립니다. 감사합니다.